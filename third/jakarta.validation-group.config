# rules for jakarta.validation
json.cache.disable=true
json.group=groovy:session.get("json-group")
param.before=groovy:```
    session.set("json-group", it.annValue("org.springframework.validation.annotation.Validated"))
```
param.after=groovy:```
    session.remove("json-group")
```
jakarta_check_groups=```
    for(annMap in annMaps){
        def fieldGroups = annMap["groups"] ?: [helper.findClass("jakarta.validation.groups.Default")]
        def paramGroups = session.get("json-group") ?: [helper.findClass("jakarta.validation.groups.Default")]
        for(fieldGroup in fieldGroups){
            for(paramGroup in paramGroups){
                if(paramGroup.isExtend(fieldGroup.name())){
                    return true
                }
            }
        }
    }
    return false
```
jakarta_check_groups_return_flag=```
    def flag = false
    for(annMap in annMaps){
        def fieldGroups = annMap["groups"] ?: [helper.findClass("jakarta.validation.groups.Default")]
        def paramGroups = session.get("json-group") ?: [helper.findClass("jakarta.validation.groups.Default")]
        for(fieldGroup in fieldGroups){
            for(paramGroup in paramGroups){
                if(paramGroup.isExtend(fieldGroup.name())){
                    flag = true
                    break
                }
            }
        }
    }
```

jakarta_check_groups_return_flagMax=```
    def flagMax = false
    for(annMap in annMaps){
        def fieldGroups = annMap["groups"] ?: [helper.findClass("jakarta.validation.groups.Default")]
        def paramGroups = session.get("json-group") ?: [helper.findClass("jakarta.validation.groups.Default")]
        for(fieldGroup in fieldGroups){
            for(paramGroup in paramGroups){
                if(paramGroup.isExtend(fieldGroup.name())){
                    flagMax = true
                    break
                }
            }
        }
    }
```


jakarta_check_groups_return_flagMin=```
    def flagMin = false
    for(annMap in annMaps){
        def fieldGroups = annMap["groups"] ?: [helper.findClass("jakarta.validation.groups.Default")]
        def paramGroups = session.get("json-group") ?: [helper.findClass("jakarta.validation.groups.Default")]
        for(fieldGroup in fieldGroups){
            for(paramGroup in paramGroups){
                if(paramGroup.isExtend(fieldGroup.name())){
                    flagMin = true
                    break
                }
            }
        }
    }
```

#Support for jakarta.validation annotations
field.required[@jakarta.validation.constraints.NotBlank]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.NotBlank")
    ${jakarta_check_groups}
```
field.required[@jakarta.validation.constraints.NotNull]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.NotNull")
     ${jakarta_check_groups}
```
field.required[@jakarta.validation.constraints.NotEmpty]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.NotEmpty")
    ${jakarta_check_groups}
```
param.required=@jakarta.validation.constraints.NotBlank
param.required=@jakarta.validation.constraints.NotNull
param.required=@jakarta.validation.constraints.NotEmpty



###set resolveMulti = first
# define var
number_min=-9999
number_max=9999
float_dmin=2
java_integer_types=["java.lang.Integer","int","java.lang.Long","long","java.lang.Short","short","java.math.BigInteger"]
java_float_types=["java.lang.String","java.lang.Float","float","java.lang.Double","double","java.math.BigDecimal"]
# mock_integer_or_float=${java_integer_types}.contains(it.type().name())?"@integer":"@float"

# AssertTrue|AssertFalse
field.mock[@jakarta.validation.constraints.AssertTrue]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.AssertTrue")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return true
    }
```
field.demo[@jakarta.validation.constraints.AssertTrue]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.AssertTrue")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return true
    }
```
field.mock[@jakarta.validation.constraints.AssertFalse]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.AssertFalse")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return false
    }
```
field.demo[@jakarta.validation.constraints.AssertFalse]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.AssertFalse")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return false
    }
```

# DecimalMax+DecimalMin -mock
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
    ${jakarta_check_groups_return_flagMin}
    annMaps = it.annMaps("jakarta.validation.constraints.DecimalMax")
    ${jakarta_check_groups_return_flagMax}
    if(flagMin&&flagMax){
        return "@integer("+it.ann("jakarta.validation.constraints.DecimalMin")+","+it.ann("jakarta.validation.constraints.DecimalMax")+")"
    }else if(flagMin&&!flagMax){
        return "@integer("+it.ann("jakarta.validation.constraints.DecimalMin")+")"
    }else if(!flagMin&&flagMax){
        return "@integer(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+")"
    }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
    ${jakarta_check_groups_return_flagMin}
    annMaps = it.annMaps("jakarta.validation.constraints.DecimalMax")
    ${jakarta_check_groups_return_flagMax}
    if(flagMin&&flagMax){
        return "@float("+it.ann("jakarta.validation.constraints.DecimalMin")+","+it.ann("jakarta.validation.constraints.DecimalMax")+",${float_dmin})"
    }else if(flagMin&&!flagMax){
        return "@float("+it.ann("jakarta.validation.constraints.DecimalMin")+",${number_max},${float_dmin})"
    }else if(!flagMin&&flagMax){
        return "@float(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+",${float_dmin})"
    }
```

# DecimalMax|DecimalMin  -mock
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
      def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMax")
      ${jakarta_check_groups_return_flagMax}
      if(flagMax){
         return "@integer(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+")"
      }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
     ${jakarta_check_groups_return_flagMin}
     if(flagMin){
         return "@integer("+it.ann("jakarta.validation.constraints.DecimalMin")+")"
     }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMax")
     ${jakarta_check_groups_return_flagMax}
     if(flagMax){
         return "@float(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+",${float_dmin})"
     }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
     ${jakarta_check_groups_return_flagMin}
     if(flagMin){
         return "@float("+it.ann("jakarta.validation.constraints.DecimalMin")+",${number_max},${float_dmin})"
     }
```

# DecimalMax、DecimalMin  -advanced
field.advanced[@jakarta.validation.constraints.DecimalMax]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMax")
    ${jakarta_check_groups_return_flag}
    if(flag){
        def ann = it.annMap("jakarta.validation.constraints.DecimalMax")
        return [maximum:ann["value"],exclusiveMaximum:(ann["inclusive"]==false)]
    }
```
field.advanced[@jakarta.validation.constraints.DecimalMin]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
    ${jakarta_check_groups_return_flag}
    if(flag){
        def ann = it.annMap("jakarta.validation.constraints.DecimalMin")
        return [minimum:ann["value"],exclusiveMinimum:(ann["inclusive"]==false)]
    }
```

# jakarta.validation.constraints.Digits
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Digits")
    ${jakarta_check_groups_return_flag}
    if(flag){
        def max = "9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer")).toInteger()
        return "@integer("+(-max)+","+max+")"
    }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Digits")
    ${jakarta_check_groups_return_flag}
    if(flag){
            def max = ("9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer"))+"."+"9".repeat(it.annValue("jakarta.validation.constraints.Digits","fraction"))).toDouble()
            return "@float("+(-max)+","+max+",0,"+it.ann("jakarta.validation.constraints.Digits","fraction")+")"
    }
```

field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Digits")
    ${jakarta_check_groups_return_flag}
    if(flag){
          def max = "9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer")).toInteger()
          return [minimum:-max,maximum:max]
    }
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Digits")
    ${jakarta_check_groups_return_flag}
    if(flag){
          def max = ("9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer"))+"."+"9".repeat(it.annValue("jakarta.validation.constraints.Digits","fraction"))).toDouble()
          return [minimum:-max,maximum:max]
    }
```

# jakarta.validation.constraints.Email
field.mock[@jakarta.validation.constraints.Email]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Email")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return "@email"
    }
```
field.advanced[@jakarta.validation.constraints.Email]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.Email")
    ${jakarta_check_groups_return_flag}
    def emailData = [:]
    if(flag){
        emailData["format"] = "email"
    }
    return emailData
```

# Max+Min
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&it.hasAnn("jakarta.validation.constraints.Min")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
        def annMaps = it.annMaps("jakarta.validation.constraints.Min")
        ${jakarta_check_groups_return_flagMin}
        annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
        ${jakarta_check_groups_return_flagMax}
        if(flagMin&&flagMax){
            return  "@integer("+it.ann("jakarta.validation.constraints.Min")+","+it.ann("jakarta.validation.constraints.Max")+")"
        }else if(flagMin&&!flagMax){
            return "@integer("+it.ann("jakarta.validation.constraints.Min")+")"
        }else if(!flagMin&&flagMax){
            return "@integer(0,"+it.ann("jakarta.validation.constraints.Max")+")"
        }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&it.hasAnn("jakarta.validation.constraints.Min")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.Min")
     ${jakarta_check_groups_return_flagMin}
     annMaps = it.annMaps("jakarta.validation.constraints.DecimalMin")
     ${jakarta_check_groups_return_flagMax}
      if(flagMin&&flagMax){
          return  "@float("+it.ann("jakarta.validation.constraints.Min")+","+it.ann("jakarta.validation.constraints.Max")+",${float_dmin})"
      }else if(flagMin&&!flagMax){
          return "@float("+it.ann("jakarta.validation.constraints.Min")+",${number_max},${float_dmin})"
      }else if(!flagMin&&flagMax){
          return "@float(0,"+it.ann("jakarta.validation.constraints.Max")+")"
      }
```

# Max|Min
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
      def annMaps = it.annMaps("jakarta.validation.constraints.Max")
      ${jakarta_check_groups_return_flagMax}
      if(flagMax){
         return  "@integer(0,"+it.ann("jakarta.validation.constraints.Max")+")"
      }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Min")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.Min")
     ${jakarta_check_groups_return_flagMin}
     if(flagMin){
         return "@integer("+it.ann("jakarta.validation.constraints.Min")+")"
     }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.Max")
          ${jakarta_check_groups_return_flagMax}
          if(flagMax){
             return  "@float(0,"+it.ann("jakarta.validation.constraints.Max")+")"
          }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Min")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.Min")
     ${jakarta_check_groups_return_flagMin}
     if(flagMin){
         return "@float("+it.ann("jakarta.validation.constraints.Min")+",${number_max},${float_dmin})"
     }
```

# Max、Min  -advanced
field.advanced[@jakarta.validation.constraints.Max]=groovy:```
        def annMaps = it.annMaps("jakarta.validation.constraints.Max")
        ${jakarta_check_groups_return_flag}
        if(flag){
            def ann = it.annMap("jakarta.validation.constraints.Max")
            return [maximum:it.ann("jakarta.validation.constraints.Max")]
        }
```
field.advanced[@jakarta.validation.constraints.Min]=groovy:```
        def annMaps = it.annMaps("jakarta.validation.constraints.Min")
        ${jakarta_check_groups_return_flag}
        if(flag){
            def ann = it.annMap("jakarta.validation.constraints.Min")
            return [minimum:it.ann("jakarta.validation.constraints.Min")]
        }
```

# Negative&NegativeOrZero
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
        def annMaps = it.annMaps("jakarta.validation.constraints.Negative")
        ${jakarta_check_groups_return_flag}
        if(flag){
            return  "@integer(${number_min},-1)"
        }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.NegativeOrZero")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
         def annMaps = it.annMaps("jakarta.validation.constraints.NegativeOrZero")
                ${jakarta_check_groups_return_flag}
                if(flag){
                    return  "@integer(${number_min},0)"
        }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
     def annMaps = it.annMaps("jakarta.validation.constraints.Negative")
                ${jakarta_check_groups_return_flag}
                if(flag){
                    return  "@float(${number_min},0.01,${float_dmin})"
        }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.NegativeOrZero")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
 def annMaps = it.annMaps("jakarta.validation.constraints.NegativeOrZero")
                ${jakarta_check_groups_return_flag}
                if(flag){
                    return  "@float(${number_min},0,${float_dmin})"
        }
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.Negative")
    ${jakarta_check_groups_return_flag}
    def neData = [:]
    if(flag){
        neData["maximum"] = -1
    }
    return neData
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.Negative")
    ${jakarta_check_groups_return_flag}
    def neData = [:]
    if(flag){
        neData["maximum"] = -0.001
    }
    return neData
```
field.advanced[@jakarta.validation.constraints.NegativeOrZero]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.NegativeOrZero")
    ${jakarta_check_groups_return_flag}
    def neData = [:]
    if(flag){
        neData["maximum"] = 0
    }
    return neData
```

# jakarta.validation.constraints.Pattern
field.advanced[@jakarta.validation.constraints.Pattern]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Pattern")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return tool.toJson([pattern:it.ann("jakarta.validation.constraints.Pattern","regexp")])
    }
```

# Positive&PositiveOrZero
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
   def annMaps = it.annMaps("jakarta.validation.constraints.Positive")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return "@integer(1,${number_max})"
    }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.PositiveOrZero")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
   def annMaps = it.annMaps("jakarta.validation.constraints.PositiveOrZero")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return "@integer(0,${number_max})"
    }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
   def annMaps = it.annMaps("jakarta.validation.constraints.Positive")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return "@float(0.01,${number_max},${float_dmin})"
    }
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.PositiveOrZero")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
   def annMaps = it.annMaps("jakarta.validation.constraints.PositiveOrZero")
    ${jakarta_check_groups_return_flag}
    if(flag){
        return "@float(0,${number_max},${float_dmin})"
    }
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.Positive")
    ${jakarta_check_groups_return_flag}
    def poData = [:]
    if(flag){
        poData["minimum"] = 1
    }
    return poData
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
  def annMaps = it.annMaps("jakarta.validation.constraints.Positive")
    ${jakarta_check_groups_return_flag}
    def poData = [:]
    if(flag){
        poData["minimum"] = 0.001
    }
    return poData
```
field.advanced[@jakarta.validation.constraints.PositiveOrZero]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.PositiveOrZero")
        ${jakarta_check_groups_return_flag}
        def poData = [:]
        if(flag){
            poData["minimum"] = 0
        }
        return poData
```

# jakarta.validation.constraints.Size

field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Size")&&it.jsonType().name()=="java.lang.String"]=groovy:```
   def annMaps = it.annMaps("jakarta.validation.constraints.Size")
    ${jakarta_check_groups_return_flag}
    if(flag){
           def ann = it.annMap("jakarta.validation.constraints.Size")
           if(ann.containsKey("min")&&ann.containsKey("max")){
               return "@string("+ann["min"]+","+ann["max"]+")"
           }else if(ann.containsKey("min")){
               return "@string("+ann["min"]+")"
           }else if(ann.containsKey("max")){
               return "@string(0,"+ann["max"]+")"
           }
    }
```
field.advanced[@jakarta.validation.constraints.Size]=groovy:```
    def annMaps = it.annMaps("jakarta.validation.constraints.Size")
    ${jakarta_check_groups_return_flag}
    if(flag){
          def element = (it.jsonType().name() == "java.lang.String")?"Length":"Items"
          def ann = it.annMap("jakarta.validation.constraints.Size")
          def advanced = [:]
          if(ann.containsKey("min")){
              advanced["min"+element] = ann["min"]
          }
          if(ann.containsKey("max")){
              advanced["max"+element] = ann["max"]
          }
          return advanced
    }
```
###set resolveMulti = error