# rules for jakarta.validation

#Support for jakarta.validation annotations
param.required=@jakarta.validation.constraints.NotBlank
param.required=@jakarta.validation.constraints.NotNull
param.required=@jakarta.validation.constraints.NotEmpty
field.required=@jakarta.validation.constraints.NotBlank
field.required=@jakarta.validation.constraints.NotNull
field.required=@jakarta.validation.constraints.NotEmpty

###set resolveMulti = first
# define var
number_min=-9999
number_max=9999
float_dmin=2
java_integer_types=["java.lang.Integer","int","java.lang.Long","long","java.lang.Short","short","java.math.BigInteger"]
java_float_types=["java.lang.String","java.lang.Float","float","java.lang.Double","double","java.math.BigDecimal"]
# mock_integer_or_float=${java_integer_types}.contains(it.type().name())?"@integer":"@float"

# AssertTrue|AssertFalse
field.mock[@jakarta.validation.constraints.AssertFalse]=false
field.demo[@jakarta.validation.constraints.AssertFalse]=false
field.mock[@jakarta.validation.constraints.AssertTrue]=true
field.demo[@jakarta.validation.constraints.AssertTrue]=true

# DecimalMax+DecimalMin -mock
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer("+it.ann("jakarta.validation.constraints.DecimalMin")+","+it.ann("jakarta.validation.constraints.DecimalMax")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float("+it.ann("jakarta.validation.constraints.DecimalMin")+","+it.ann("jakarta.validation.constraints.DecimalMax")+",${float_dmin})"

# DecimalMax|DecimalMin  -mock
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer("+it.ann("jakarta.validation.constraints.DecimalMin")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMax")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(0,"+it.ann("jakarta.validation.constraints.DecimalMax")+",${float_dmin})"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.DecimalMin")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float("+it.ann("jakarta.validation.constraints.DecimalMin")+",${number_max},${float_dmin})"

# DecimalMax、DecimalMin  -advanced
field.advanced[@jakarta.validation.constraints.DecimalMax]=groovy:```
    def ann = it.annMap("jakarta.validation.constraints.DecimalMax")
    return [maximum:ann["value"],exclusiveMaximum:(ann["inclusive"]==false)]
```
field.advanced[@jakarta.validation.constraints.DecimalMin]=groovy:```
    def ann = it.annMap("jakarta.validation.constraints.DecimalMin")
    return [minimum:ann["value"],exclusiveMinimum:(ann["inclusive"]==false)]
```

# jakarta.validation.constraints.Digits
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
    def max = "9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer")).toInteger()
    return "@integer("+(-max)+","+max+")"
```
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
    def max = ("9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer"))+"."+"9".repeat(it.annValue("jakarta.validation.constraints.Digits","fraction"))).toDouble()
    return "@float("+(-max)+","+max+",0,"+it.ann("jakarta.validation.constraints.Digits","fraction")+")"
```

field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:```
    def max = "9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer")).toInteger()
    return [minimum:-max,maximum:max]
```
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Digits")&&${java_float_types}.contains(it.jsonType().name())]=groovy:```
    def max = ("9".repeat(it.annValue("jakarta.validation.constraints.Digits","integer"))+"."+"9".repeat(it.annValue("jakarta.validation.constraints.Digits","fraction"))).toDouble()
    return [minimum:-max,maximum:max]
```


# jakarta.validation.constraints.Email
field.mock[@jakarta.validation.constraints.Email]=groovy:"@email"
field.advanced[@jakarta.validation.constraints.Email]={"format":"email"}

# Max+Min
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&it.hasAnn("jakarta.validation.constraints.Min")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer("+it.ann("jakarta.validation.constraints.Min")+","+it.ann("jakarta.validation.constraints.Max")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&it.hasAnn("jakarta.validation.constraints.Min")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float("+it.ann("jakarta.validation.constraints.Min")+","+it.ann("jakarta.validation.constraints.Max")+",${float_dmin})"

# Max|Min
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(0,"+it.ann("jakarta.validation.constraints.Max")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Min")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer("+it.ann("jakarta.validation.constraints.Min")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Max")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(0,"+it.ann("jakarta.validation.constraints.Max")+")"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Min")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float("+it.ann("jakarta.validation.constraints.Min")+",${number_max},${float_dmin})"

# Max、Min  -advanced
field.advanced[@jakarta.validation.constraints.Max]=groovy:```
    return [maximum:it.ann("jakarta.validation.constraints.Max")]
```
field.advanced[@jakarta.validation.constraints.Min]=groovy:```
    return [minimum:it.ann("jakarta.validation.constraints.Min")]
```

# Negative&NegativeOrZero
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(${number_min},-1)"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.NegativeOrZero")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(${number_min},0)"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(${number_min},0.01,${float_dmin})"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.NegativeOrZero")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(${number_min},0,${float_dmin})"

field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_integer_types}.contains(it.jsonType().name())]={maximum:-1}
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Negative")&&${java_float_types}.contains(it.jsonType().name())]={maximum:-0.001}
field.advanced[@jakarta.validation.constraints.NegativeOrZero]={"maximum":0}

# jakarta.validation.constraints.Pattern
field.advanced[@jakarta.validation.constraints.Pattern]=groovy:```
    return tool.toJson([pattern:it.ann("jakarta.validation.constraints.Pattern","regexp")])
```

# Positive&PositiveOrZero
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(1,${number_max})"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.PositiveOrZero")&&${java_integer_types}.contains(it.jsonType().name())]=groovy:"@integer(0,${number_max})"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(0.01,${number_max},${float_dmin})"
field.mock[groovy:it.hasAnn("jakarta.validation.constraints.PositiveOrZero")&&${java_float_types}.contains(it.jsonType().name())]=groovy:"@float(0,${number_max},${float_dmin})"
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_integer_types}.contains(it.jsonType().name())]={minimum:1}
field.advanced[groovy:it.hasAnn("jakarta.validation.constraints.Positive")&&${java_float_types}.contains(it.jsonType().name())]={minimum:0.001}
field.advanced[@jakarta.validation.constraints.PositiveOrZero]={minimum:0}

# jakarta.validation.constraints.Size

field.mock[groovy:it.hasAnn("jakarta.validation.constraints.Size")&&it.jsonType().name()=="java.lang.String"]=groovy:```
    def ann = it.annMap("jakarta.validation.constraints.Size")
    if(ann.containsKey("min")&&ann.containsKey("max")){
        return "@string("+ann["min"]+","+ann["max"]+")"
    }else if(ann.containsKey("min")){
        return "@string("+ann["min"]+")"
    }else if(ann.containsKey("max")){
        return "@string(0,"+ann["max"]+")"
    }
```
field.advanced[@jakarta.validation.constraints.Size]=groovy:```
    def element = (it.jsonType().name() == "java.lang.String")?"Length":"Items"
    def ann = it.annMap("jakarta.validation.constraints.Size")
    def advanced = [:]
    if(ann.containsKey("min")){
        advanced["min"+element] = ann["min"]
    }
    if(ann.containsKey("max")){
        advanced["max"+element] = ann["max"]
    }
    return advanced
```
###set resolveMulti = error

